import { DEVELOPMENT_MODE } from '@/config';
import { FALLBACK } from '@/constants';
import { logger } from '@/utils';

import { Search } from './Search';

import type {
  DetailedUid,
  IndexedStories,
  Logger,
  Uids,
  UidStory,
  UsageTreeOptions,
} from '@/types';
import type { API_IndexHash } from '@storybook/types';

const hydrateLog = logger(DEVELOPMENT_MODE, 'hydrate');

class UsageTree {
  //===================================
  //== Private Readonly Properties
  //===================================
  /** The base path that relative paths are relative to. */
  readonly #basePath: string;
  /** Custom logger instance. */
  readonly #log: Logger;
  /** Search controller instance. */
  readonly #search: Search;
  // /** Array of stories that were not used while parsing. */
  // readonly #unusedStories: ParsedStoryFile[];

  //===================================
  //== Public Readonly Properties
  //===================================
  /** Function to inject generated UIDs to the story index. */
  public readonly generateUidStories: (storiesIndex: API_IndexHash | undefined) => IndexedStories;
  /** Function  */
  public readonly getFilteredItems: (searchTerm: string) => UidStory[];
  /** The UIDs generated by the vite plugin. */
  public readonly uids: Uids;

  //===================================
  //== Constructor
  //===================================
  public constructor({ basePath, /*  tree, */ uids /* unusedStories */ }: UsageTreeOptions) {
    this.#basePath = basePath;
    this.#log = logger(DEVELOPMENT_MODE, 'usage-tree');
    this.#search = new Search({ tree: this });
    this.uids = uids;
    // this.#unusedStories = unusedStories;

    this.generateUidStories = this.#search.generateUidStories.bind(this.#search);
    this.getFilteredItems = this.#search.filterItems.bind(this.#search);

    this.#log.verbose('Usage Tree Loaded');
  }

  //===================================
  //== Public Static Methods
  //===================================
  /**
   * Loads the cached data from the vite plugin and restores it into a
   * {@link UsageTree} to allow for UID and component tree access.
   * @param id The ID of the storybook instance.
   * @returns A promise that resolves to a hydrated UsageTree.
   */
  public static async hydrate(id: string | undefined = FALLBACK.STORYBOOK_ID): Promise<UsageTree> {
    try {
      const cache = await import(`.cache/storybook-addon-usage`);
      const treeData = cache.default[id];
      if (treeData) {
        // Hydrate
        const { basePath, tree, uids, unusedStories } = treeData;
        return new UsageTree({ basePath, tree, uids, unusedStories });
      }
    } catch (error) {
      hydrateLog.error(`${error}`);
    }
    // Fallback tree - this may not work once serialized FileNode contains more info.
    return new UsageTree({
      basePath: '',
      tree: { filePath: '' },
      uids: {},
      unusedStories: [],
    });
  }

  //===================================
  //== Public Methods
  //===================================
  /**
   * Gets all UIDs that relate to a specific story file.
   * @param storyPath The path to the Story File.
   * @returns The {@link DetailedUid} for the story file provided.
   */
  public getComponentUids(storyPath: string | undefined): DetailedUid[] {
    return Object.values(this.uids).filter(
      uid => this.toRelativePath(uid.storyFilePath) === storyPath,
    );
  }

  /**
   * Converts an absolute path to relative to match paths returned by the
   * Storybook API.
   * @param path The path to convert to relative.
   * @returns The relative path, or `undefined` if passed `null`/`undefined`.
   */
  public toRelativePath(path: string | null | undefined): string | undefined {
    return path?.replace(this.#basePath, './').replace(/\/+/giu, '/');
  }
}

export { UsageTree };
